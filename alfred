#!/usr/bin/env perl

use 5.10.0;
use strict;
use autodie;
use warnings;

# custom search paths
BEGIN {
    use File::Basename;
    use Cwd qw/abs_path/;

    my $alf = dirname abs_path $0;
    push @INC,
        $alf.'/lib',
        $alf.'/tasks',
        $alf.'/local/lib/perl5';
}

use File::Path qw/rmtree/;
use File::Find qw/find/;

use Alfred::Cli;
use Alfred::Cron;
use Alfred::Task;
use Alfred::Queue;
use Alfred::Daemon;

sub usage {
    my $help = <<"HELP";

Alfred - Easily manage your server tasks!

\$ alfred install                 - Install itself to the current user path.
\$ alfred help                    - Show this help message.
\$ alfred daemon                  - Starts Alfred daemon.
\$ alfred dismiss                 - Stops Alfred daemon.
\$ alfred list                    - List all available tasks.
\$ alfred queue                   - List all tasks currently in the queue.
\$ alfred help <task>             - Show help information for the given task.
\$ alfred new <task>              - Create a new task.
\$ alfred purge <task>            - Destroy the given task.
\$ alfred run <task>              - Execute the given task.
\$ alfred schedule <task>         - Add the given task to the daemon queue.
\$ alfred cron <crontime> <task>  - Add a new crontab job to run the given task.


* `crontime` must be a valid crontab interval.
    e.g.:  "* * * * *"
           "0 0,12 1 */2 *"
           etc

* Optionally, you can put a username with the crontime to run the task with
  the specified user, assuming the username you want to use is 'bruce', do:

  "\@bruce * * * * *"


[[ Tasks names should be valid Perl module names ]]

    - Backup::Database
    - Site::FTP::Sync
    - etc

HELP

    say($help);
    exit;
}

my $order = Alfred::Cli::get_order();
my $task  = Alfred::Cli::get_task();


##
## HELP FROM TASK
if (!defined $order || 'help' eq $order) {
    Alfred::Task::task_help $task->{task} if $task->{task};
    usage();
}


##
## RUN TASK
elsif ('run' eq $order) {
    if ($task->{task}) {
        Alfred::Task::task_run $task;
        exit;
    }

    say('No task was given. Aborting...');
}


##
## NEW TASK
elsif ('new' eq $order) {
    if ($task->{task}) {
        if (Alfred::Task::task_exists $task->{task}) {
            say("Task '${\$task->{task}}' already exists.");
            exit;
        }

        my $path = Alfred::Task::task_new $task->{task};

        if (! $path) {
            say("There was an error trying to create task '${\$task->{task}}'.");
        }
        else {
            say($path);
        }
    }
}


##
## INSTALL ALFRED TO USER PATH
elsif ('install' eq $order) {
    open(my $FH, '>>', $ENV{HOME}.'/.bashrc');
    print $FH "\n# Alfred bin\nexport PATH=\$PATH:". dirname(abs_path($0)) ."\n";
    close($FH);

    say('Alfred was added to the user path!');
}


##
## QUEUE TASK FOR DAEMON
elsif ('schedule' eq $order) {
    if ($task->{task}) {
        Alfred::Queue::add_task $task;
        exit;
    }

    say('No task was given. Aborting...');
}


##
## STARTS DAEMON
elsif ('daemon' eq $order) {
    Alfred::Daemon::daemonize();
}


##
## STOPS DAEMON
elsif ('dismiss' eq $order) {
    Alfred::Daemon::dismiss();
}


##
## LIST ALL TASKS IN THE QUEUE
elsif ('list' eq $order) {
    find sub {
        if (/\.pm$/) {
            my $filepath = $File::Find::name;

            $filepath =~ s/^.+\/tasks\///;
            $filepath =~ s/\//::/g;
            $filepath =~ s/\.pm$//;

            say("-> ${filepath}");
        }
    }, abs_path(dirname($0)).'/tasks';
}


##
## LIST ALL TASKS AVAILABLE
elsif ('queue' eq $order) {
    my $tasks = Alfred::Queue::list_tasks();

    if (! @$tasks) {
        say('No tasks currently on the daemon queue.');
        exit;
    }

    foreach my $task (@$tasks) {
        say("-> ${task}");
    }
}



##
## PURGE GIVEN TASK
elsif ('purge' eq $order) {
    die("No task was informed.\n")
        if (! $task->{task});

    my $task_name = my $task = $task->{task};
    my $tasks_dir = dirname(abs_path($0)) . '/tasks';

    $task =~ s/::/\//g;

    unless (defined Alfred::Task::task_exists($task_name)
            || -d "${tasks_dir}/${task}") {

        say("Task '${task_name}' doesn't exists.");
        exit;
    }

    $task = dirname(abs_path($0)) . "/tasks/${task}";

    # verify if is file or dir (or both)
    if (-e "${task}.pm") {
        unlink "${task}.pm";
    }

    if (-d $task) {
        rmtree $task;
    }

    die("Error trying to remove '${task_name}', verify the file permissions.\n")
        if -e "${task}.pm" or -d $task;

    say("The task '${task_name}' was removed.");
}



##
## ADD A NEW CRONJOB TO RUN THE GIVEN TASK
elsif ('cron' eq $order) {
    # fixing task schema
    my($crontime, $username) = Alfred::Cron::crontime_get_user($task->{task});
    my $taskname = shift @{$task->{options}};
    $task->{task} = $taskname;

    die("Invalid crontab interval.\n${crontime}\n")
        unless Alfred::Cron::is_valid_crontime $crontime;

    my $cronjob = {
        username => $username,
        interval => $crontime,
        task     => $task
    };

    Alfred::Cron::new_job $cronjob;
}
